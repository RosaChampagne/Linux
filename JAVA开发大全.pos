{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_free","leftChildren":[{"id":"6ad96ea83554","title":"中间件","parent":"root","children":[{"id":"31f1fa75ac0caf6fb372","title":"MyBatis","parent":"6ad96ea83554","children":[],"note":"MyBatis的持久化解决方案是将用户从原始的JDBC访问中解放出来,用户只需要定义需要操作的SQL语句,无须关注底层的JDBC操作,就可以以面向对象的方式来进行持久化层操作.底层数据库连接的获取,数据访问的实现,事务控制等都无须用户关心,从而将应用层从底层的JDBC/JTA API抽取出来.通过配置文件管理JDBC连接,让MyBatis解决持久化的实现."}]},{"id":"c27537624398","title":"服务器<br>","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border":"0px none rgb(255, 255, 255)"},"children":[{"id":"c3c6374c12d2","title":"Tomcat<br>","parent":"c27537624398","children":[{"id":"bd3683c8f7b9","title":"Tomact架构及模块","task":{"priority":"1"},"children":[{"id":"0447aa36a922","title":"Server","children":[{"id":"725deafbaa20","title":"Service +","children":[{"id":"9d269a3d4f19","title":"Connector +","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border":"0px none rgb(255, 255, 255)"},"children":[],"parent":"725deafbaa20","note":"* 一个Service下可以有多个Connector，这事因为一个服务可以有多个连接，如同时提供Http和Https链接，BIO,NIO链接\n* Connector用户处理连接相关的事情，并提供Socket与Request和Response的相关转化。\n* Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！"},{"id":"5d1c17969fb5","title":"Container -","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border":"0px none rgb(255, 255, 255)"},"children":[],"parent":"725deafbaa20","note":"* 一个Service下只有一个Container\n* Container用于封装和管理Servlet，以及具体处理Request请求"},{"id":"c9709eabfbc7","title":"Jasper","children":[],"parent":"725deafbaa20"},{"id":"c62fab5244a0","title":"Naming","children":[],"parent":"725deafbaa20"},{"id":"7d47203ce461","title":"Session","children":[],"parent":"725deafbaa20"},{"id":"087ebef58b0b","title":"Loging","children":[],"parent":"725deafbaa20"},{"id":"c2f1ac8c7c27","title":"JMX","children":[],"parent":"725deafbaa20"}],"parent":"0447aa36a922","note":"Service对外提供服务"}],"parent":"bd3683c8f7b9","note":"Tomcat中最顶层的容器，代表整个服务器，掌握整个Tomcat的生命周期。\n\n（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container； \n（2） Server掌管着整个Tomcat的生死大权； \n（4）Service 是对外提供服务的； \n（5）Connector用于接受请求并将请求封装成Request和Response来具体处理； \n（6）Container用于封装和管理Servlet，以及具体处理request请求；"}],"parent":"c3c6374c12d2","icons":[{"index":"0","color":"rgb(113, 203, 45)","name":"priority"}]},{"id":"59e700906f3b","title":"Tomcat配置管理","task":{"priority":"2"},"children":[{"id":"c926f66c0b8a","title":"Web应用配置<br>web.xml","children":[{"id":"27af399d9e75","title":"定义：web.xml是Web应用的部署描述文件，它支持的元素及属性<br>来自于Servlet规范定义。","children":[],"parent":"c926f66c0b8a"},{"id":"7987b38b7b1f","title":"描述文件的配置分类","children":[{"id":"64d75e92e727","title":"ServletContext初始化参数<br>&lt;context-param&gt;&lt;/context-param&gt;","children":[],"parent":"7987b38b7b1f","note":"&lt;context-param&gt;\n  &lt;description&gt;Test&lt;/description&gt;\n&lt;param-name&gt;name&lt;/param-name&gt;\n&lt;param-value&gt;&lt;/param-value&gt;\n&lt;/context-param&gt;"},{"id":"2c8bb23807aa","title":"会话配置<br>&lt;session-config&gt;&lt;/session-config&gt;<br>默认是30分钟","children":[],"parent":"7987b38b7b1f"},{"id":"2b4b0cdcddc6","title":"应用生命周期监听<br>&lt;listener&gt;&lt;/listener&gt;","parent":"7987b38b7b1f","children":[]},{"id":"b0ac36ac16f6","title":"Filter定义及映射<br>用于配置Web应用过滤器，用来过滤资源请求及响应。<br>经常用于认证、日志、加密、数据转换等。<br>&lt;filter&gt;&lt;/filter&gt;<br>&lt;filter-mapping&gt;&lt;/filter-mapping&gt;<br>","parent":"7987b38b7b1f","children":[]},{"id":"3e03d9ffc761","title":"MIME类型映射<br>&lt;mime-mapping&gt;&lt;/mime-mapping&gt;","parent":"7987b38b7b1f","children":[]},{"id":"0b44d53a5997","title":"欢迎文件列表<br>&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt;","parent":"7987b38b7b1f","children":[]},{"id":"7e04552a4f7b","title":"错误页面<br>&lt;error-page&gt;&lt;/error-page&gt;","parent":"7987b38b7b1f","children":[]},{"id":"2e0fbb06aec4","title":"本地化及编码映射<br>&lt;locale-encoding-mapping-list&gt;&lt;/locale-encoding-mapping-list&gt;","parent":"7987b38b7b1f","children":[]},{"id":"7c53489d2a7a","title":"完全配置<br>&lt;security-constraint&gt;&lt;/security-constraint&gt;<br>&lt;security-role&gt;&lt;/security-role&gt;","parent":"7987b38b7b1f","children":[]},{"id":"a9bef7476f3e","title":"JNDI配置","parent":"7987b38b7b1f","children":[]}],"parent":"c926f66c0b8a"}],"parent":"59e700906f3b","collapsed":false},{"id":"f74baaeceae3","title":"Tomcat日志配置","parent":"59e700906f3b","children":[{"id":"b426993471c1","title":"运行中的日志","parent":"f74baaeceae3","children":[{"id":"397e2fb1a2d4","title":"分5类：catalina、localhost、manager、admin、host-manager","children":[],"parent":"b426993471c1"},{"id":"fa971ade9da3","title":"分7中日志级别: SERVER &gt; WARNING &gt; INFO &gt; CONFIG &gt; FINE &gt; FINER &gt; FINEST<br>默认级别为FINE","children":[],"parent":"b426993471c1"},{"id":"e1f59876a967","title":"修改conf/logging.properties中的内容来设定日志级别<br>设置catalina日志级别为FINE<br>1catalina.org.apache.juli.FileHandler.level = FINE<br>禁用catalina日志输出<br>1catalina.org.apache.juli.FileHandler.level = OFF<br>输出catalina所有的日志消息输出<br>1catalina.org.apache.juli.FileHandler.level = ALL","children":[],"parent":"b426993471c1"}],"note":"记录运行的一些信息，尤其是一些异常错误日志信息\n可配合commons-logging / log4j搭配输出日志\nhttp://xstarcd.github.io/wiki/Java/tomcat_log.html"},{"id":"6e03cdc1cb89","title":"访问日志","parent":"f74baaeceae3","children":[{"id":"fa36d4ad5c9e","title":"修改tomcat/conf/server.xml中Host下的Valve，去掉注释<br>        &lt;Valve className=\"org.apache.catalina.valves.AccessLogValve\"<br>         directory=\"logs\"  prefix=\"localhost_access_log.\" suffix=\".txt\"<br>         pattern=\"common\" resolveHosts=\"false\"/&gt;<br>可修改pattern来修改输出","parent":"6e03cdc1cb89","children":[]}],"note":"记录的是访问的时间，IP，访问的resource等相关信息。可以用于前端优化，从访问日志可以看出系统的访问热点主要集中在哪里，可以通过GoAccess来分析结果。"}],"collapsed":true},{"id":"991a6b026e5d","title":"catalina容器启动阶段的配置，如服务器类加载器路径等<br>conf/catalina.properties","children":[],"parent":"59e700906f3b"},{"id":"acff737f5f67","title":"server.xml配置<br>tomcat应用服务器核心配置文件","children":[{"id":"fcbc7e5b6fe0","title":"acceptorThreadCount:接收socket连接的线程数<br>maxThread：最大线程数<br>acceptCount：最大线程数占满后，可以接受排队的队列长度；若acceptCount也占满了，返回connection refused","parent":"acff737f5f67","children":[]}],"parent":"59e700906f3b"}],"parent":"c3c6374c12d2","icons":[{"index":"1","color":"rgb(113, 203, 45)","name":"priority"}],"collapsed":true},{"id":"b2091972ab12","title":"Tomcat安全","task":{"priority":"3"},"children":[{"id":"29f0b2371a64","title":"1. 专门创建一个用户只用于tomcat的服务，防止入侵者直接拿到root权限执行webshell","parent":"b2091972ab12","children":[]},{"id":"548d835f67b7","title":"2. 修改管理端口及关闭服务的字符串8005 SHUTDOWN","parent":"b2091972ab12","children":[]},{"id":"fb10709ad5e6","title":"3. 隐藏服务器信息。添加自定义error pages，修改tomcat信息","parent":"b2091972ab12","children":[]},{"id":"545d7aab2ac3","title":"4. 禁止tomcat遍历目录 listings=false","parent":"b2091972ab12","children":[]},{"id":"4a5c32046e7f","title":"5. 去除Host组建的自动部署","parent":"b2091972ab12","children":[]},{"id":"29cad2abdfcc","title":"6. 可以删除掉AJP connector","parent":"b2091972ab12","children":[]}],"parent":"c3c6374c12d2","icons":[{"index":"2","color":"rgb(113, 203, 45)","name":"priority"}],"note":"https://github.com/zhonghuasheng/Tutorial/wiki/Tomcat%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE"}],"note":"https://mp.weixin.qq.com/s?__biz=MzI4OTA3NDQ0Nw==&mid=2455546034&idx=1&sn=c6df9d5600532f2661848958ed3929a6&chksm=fb9cb4d2cceb3dc47fe8153d9f91c5f57c69e3fa804c19b8a30c8c94e69b1606ca28f3c977ba&mpshare=1&scene=1&srcid=0321jY3HRMYUQ4lf1EqTNDMY#rd\n","collapsed":false}],"parent":"root","collapsed":true},{"id":"5e1bb582797b","title":"设计模式","children":[{"id":"243144a811a3","title":"为什么要使用设计模式","parent":"5e1bb582797b","children":[]},{"id":"1c39fb9bb997","title":"分类","children":[{"id":"e46e581e8fce","title":"creational(创建型)","children":[{"id":"91c90e13b393","title":"Singleton Pattern<br>","children":[{"id":"274dcbc43621","title":"保证一个类仅有一个实例，并提供一个访问它的全局访问点","parent":"91c90e13b393","children":[]}],"parent":"e46e581e8fce"},{"id":"a1fa8489469f","title":"Factory Pattern<br>工厂模式","children":[{"id":"a1c470c77b88","title":"Static Factory Method<br>简单工厂","parent":"a1fa8489469f","children":[{"id":"50bb68a12988","title":"简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定<br>应该创建哪一个产品类","parent":"a1c470c77b88","children":[]},{"id":"3b9b5793653d","title":"Spring中的BeanFactory","parent":"a1c470c77b88","children":[]}]}],"parent":"e46e581e8fce"},{"id":"695f0cf1e8fe","title":"Abstract Factory Pattern<br>","children":[],"parent":"e46e581e8fce"},{"id":"9ca174facb64","title":"Builder Pattern<br>","children":[],"parent":"e46e581e8fce"},{"id":"ce0402428239","title":"Prototype Pattern<br>","children":[],"parent":"e46e581e8fce"}],"parent":"1c39fb9bb997"},{"id":"68f4fed0b20a","title":"structural(结构型)<br>","children":[],"parent":"1c39fb9bb997"},{"id":"915922b389a6","title":"behavioral(行为型)","children":[],"parent":"1c39fb9bb997"}],"parent":"5e1bb582797b","collapsed":false}],"parent":"root","collapsed":true},{"id":"0c12b4509332","title":"数据结构与算法","children":[],"parent":"root"},{"id":"d7aacff2a1ba","title":"云产品","children":[{"id":"5b13ce7d2af0","title":"AWS","children":[{"id":"77c1046f4302","title":"域名解析-Route 53<br>* Godady<br>","children":[],"parent":"5b13ce7d2af0","note":"分很多区，类似中国的华中，华北，每个区叫hosted zone,可以有专属域名（www.abc.com）和通用域名(*.abc.com)"},{"id":"fa5e290d2200","title":"内容分发服务器-CloudFront<br>","parent":"5b13ce7d2af0","children":[],"note":"在validate中输入/*会自动拉取服务中的静态资源，当有静态资源更新时需要更新cdn中的文件。"},{"id":"929dbdfe579f","title":"负载均衡器-Load Balancers<br>","children":[{"id":"ab82a14cc7c9","title":"Classic ELB","parent":"929dbdfe579f","children":[]},{"id":"e9cc4c733c08","title":"Application Load Balancer","parent":"929dbdfe579f","children":[],"note":"\n"}],"parent":"5b13ce7d2af0","note":"Client访问网站时，请求会首先转发到ELB，ELB会给创建一个AWSELB/AWSALB这样的key-value的值（谁访问了哪台server），这个值会随着response返回到client端，存储在cookie中，下次client再访问的时候，AWS ELB会按照这个值将请求指定到上次的服务器\n\nALB能够按照规则（如URL）将这部分请求指定到具体的application集群\n"},{"id":"56536006505e","title":"服务器-EC2<br>","children":[],"parent":"5b13ce7d2af0"},{"id":"1efdf3b6b69f","title":"数据库-RDS<br>","parent":"5b13ce7d2af0","children":[]},{"id":"7e4f6f458aa2","title":"文件存储器-S3/EFS","parent":"5b13ce7d2af0","children":[],"note":"* S3: Simple Storage System是一种对象存储，它具有简单的Web 服务接口，可用于从Web 上的任何位置存储和检索任意数量的数据。分bucket\n* EFS-Elastic File System是由Amazon Web Services提供的云存储服务，旨在提供可扩展，弹性，并发的一些限制，以及用于AWS云服务和本地资源的加密文件存储,可以在添加和删除文件时自动增长和缩小。\n\nS3与EFS对比：\n* S3比EFS慢。S3使用的是机械硬盘，EFS使用的是固态硬盘。\n* S3在使用的时候是服务器把文件上传到S3，EFS是挂载到ec2（像机器多了块分区一样，所有的ec2都共享这块分区）"},{"id":"42af07f73acd","title":"性能监控-Cloud Watch","children":[],"parent":"5b13ce7d2af0"}],"parent":"d7aacff2a1ba"}],"parent":"root","collapsed":true},{"id":"dc2c1a0d38f3","title":"后端技术","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border":"0px none rgb(255, 255, 255)"},"parent":"root","children":[{"id":"faef5486de7416c841d8","title":"JAVA","parent":"dc2c1a0d38f3","children":[{"id":"300030983c2e","title":"JavaSE<br>","parent":"faef5486de7416c841d8","children":[{"id":"7ede64f72f49","title":"基础语法","parent":"300030983c2e","children":[{"id":"59453742b97d","title":"数据类型","parent":"7ede64f72f49","children":[{"id":"814bbc577a60","title":"8种基本数据类型","parent":"59453742b97d","children":[{"id":"1e4ea73f6ef6","title":"数值型","parent":"814bbc577a60","children":[{"id":"5d334f26537a","title":"整型","parent":"1e4ea73f6ef6","children":[{"id":"b35890b5c93c","title":"byte","parent":"5d334f26537a","children":[]},{"id":"f067f7651589","title":"short","parent":"5d334f26537a","children":[]},{"id":"8fff5d615663","title":"int","parent":"5d334f26537a","children":[]},{"id":"66d140eb6850","title":"long","parent":"5d334f26537a","children":[]}]},{"id":"da75a77e8392","title":"浮点型","parent":"1e4ea73f6ef6","children":[{"id":"ea5add37be47","title":"float","parent":"da75a77e8392","children":[]},{"id":"8f11a455fd23","title":"double","parent":"da75a77e8392","children":[]}]}]},{"id":"e1e91cb646dd","title":"字符型 char","parent":"814bbc577a60","children":[]},{"id":"b61396e7898e","title":"布尔型 boolean","parent":"814bbc577a60","children":[]}]},{"id":"bbbb4d38d83f","title":"引用类型","parent":"59453742b97d","children":[{"id":"46097f52b245","title":"类","parent":"bbbb4d38d83f","children":[]},{"id":"d1facaaedc38","title":"接口","parent":"bbbb4d38d83f","children":[]},{"id":"b2e756966a29","title":"数据","parent":"bbbb4d38d83f","children":[]}]},{"id":"278fd18851b2","title":"枚举类型 enum","parent":"59453742b97d","children":[]},{"id":"a74839787125","title":"类型转换","parent":"59453742b97d","children":[{"id":"db4a5c0684fa","title":"装箱/拆箱","children":[],"parent":"a74839787125"}]}]},{"id":"d3f10f5deed0","title":"运算符与表达式","children":[{"id":"425bc031717f","title":"算术运算符","children":[],"parent":"d3f10f5deed0","note":"单目：+（取正）、-（取负）、 ++（自增）、 - -（自减）\n双目：+、-、 *、 /、 %\n三目：a &gt; b ? true : false（说明：当a大于b的时候，为true，否则为false）"},{"id":"184498cbc08d","title":"关系运算符","children":[],"parent":"d3f10f5deed0","note":"等于：==\n不等于：!=\n大于：&gt;\n小于：&lt; \n大于等于：&gt;=\n小于等于：&lt;="},{"id":"aabc7b75ab9c","title":"赋值运算符","children":[],"parent":"d3f10f5deed0","note":"=、+=、-=、*=、/=、&=、|=、^=、&gt;&gt;=、&lt;&lt;="},{"id":"eb677dce568c","title":"移位运算符","children":[],"parent":"d3f10f5deed0","note":"左移&lt;&lt;\n右移&gt;&gt;\n无符号右移&gt;&gt;&gt;"},{"id":"c2e9003ca436","title":"位运算符","children":[],"parent":"d3f10f5deed0","note":"位与：&\n位或：|\n位取反：~\n位异或：^"}],"parent":"7ede64f72f49"},{"id":"473b1b9b1b98","title":"流程控制结构","parent":"7ede64f72f49","children":[{"id":"c63465dca331","title":"顺序结构","parent":"473b1b9b1b98","children":[]},{"id":"8e1cd2267fc6","title":"选择(条件)结构","parent":"473b1b9b1b98","children":[],"note":"switch(condition)\n{\n   case 1: \n      语句;\n      break;\n   case 2: \n      语句;\n      break;\n   default:\n      语句;\n      break;\n}\n\nif else\nif else if else"},{"id":"ead0dea0a937","title":"循环结构","parent":"473b1b9b1b98","children":[],"note":"while\ndo while\nfor\nforeach"}]},{"id":"c4b1a1eaec86","title":"重载 VS 重写","parent":"7ede64f72f49","children":[{"id":"9f7783029afe","title":"重载 overload","children":[{"id":"1f1a9c19da6e","title":"针对同一个类或者接口而言","parent":"9f7783029afe","children":[]},{"id":"4c9d3c0a3b62","title":"同名不同参","parent":"9f7783029afe","children":[]}],"parent":"c4b1a1eaec86"},{"id":"5ee26dae9816","title":"重写 override","children":[{"id":"1eed4a83270d","title":"以继承为基础，子类可以重写父类实现的方法，从而实现自己的功能","children":[],"parent":"5ee26dae9816","note":"### 注意点\n1. 子类重写父类中的方法，子类要保证方法的签名和父类相同。即子类方法的名字，返回值，参数和父类中的方法保持一致。\n2. 子类抛出的异常不能大于父类抛出的异常范围。\n3. 子类方法的访问权限不能低于父类方法的访问权限。"},{"id":"4bb6e527e211","title":"不允许重写的两种情况","parent":"5ee26dae9816","children":[{"id":"3f121446f930","title":"private修饰的方法","parent":"4bb6e527e211","children":[]},{"id":"c52c629767ea","title":"final修饰的方法","parent":"4bb6e527e211","children":[]}]}],"parent":"c4b1a1eaec86"}]}]},{"id":"64d1bbbd3c0f","title":"面向对象OOP","parent":"300030983c2e","children":[{"id":"24a14dc213ea","title":"事物","parent":"64d1bbbd3c0f","children":[{"id":"60ec130daf86","title":"对象","parent":"24a14dc213ea","children":[],"note":"一切事物皆对象\n"},{"id":"576799a30447","title":"类","parent":"24a14dc213ea","children":[],"note":"对同一类型对象的抽象表达"},{"id":"050903cad60e","title":"接口","parent":"24a14dc213ea","children":[],"note":"对行为的抽象定义，不涉及具体实现\n"}]},{"id":"1e81e94aa10e","title":"三大特性","children":[{"id":"d5c05aa0ea30","title":"封装","parent":"1e81e94aa10e","children":[{"id":"ce7c3dcbc98f","title":"属性","children":[{"id":"71f749ce7358","title":"对象的具体特征","children":[],"parent":"ce7c3dcbc98f"}],"parent":"d5c05aa0ea30"},{"id":"1c87a1408751","title":"方法","children":[{"id":"71210e961888","title":"对对象具体特征操纵的方法","children":[],"parent":"1c87a1408751"}],"parent":"d5c05aa0ea30"}]},{"id":"7c89875cfa6a","title":"继承/派生","parent":"1e81e94aa10e","children":[{"id":"ba60c7d16407","title":"类","parent":"7c89875cfa6a","children":[{"id":"551fd9691cff","title":"子类继承父类，对父类进行扩展，Java中对类的继承只允许单继承","parent":"ba60c7d16407","children":[]}]},{"id":"7d23e339d336","title":"接口","parent":"7c89875cfa6a","children":[{"id":"2d8894fcc107","title":"子类实现接口，接口中定义的方法需要在子类中实现","parent":"7d23e339d336","children":[]}]}]},{"id":"14f169f4f29a","title":"多态","parent":"1e81e94aa10e","children":[{"id":"536d312b4886","title":"即多种形态，表现为对接口和抽象类中的抽象方法的重写，每个类可以有自己不同的实现","parent":"14f169f4f29a","children":[]}]}],"parent":"64d1bbbd3c0f"},{"id":"7ea1ec4f2d4b","title":"七大设计原则<br>巧记：迪衣里开合接单","children":[{"id":"0f05cd76a5e2","title":"单一职责原则","children":[{"id":"cb076167bbd6","title":"一个类的功能尽可能单一","children":[],"parent":"0f05cd76a5e2"}],"parent":"7ea1ec4f2d4b"},{"id":"47e0ca58e99a","title":"开闭原则","parent":"7ea1ec4f2d4b","children":[{"id":"e81e4f1b28ae","title":"对扩展开放，对修改关闭","parent":"47e0ca58e99a","children":[]}]},{"id":"caba7b8601a4","title":"依赖倒置原则","parent":"7ea1ec4f2d4b","children":[{"id":"5a58d4b6b470","title":"针对抽象编程（接口和抽象类），而不是具体实现类","children":[],"parent":"caba7b8601a4"}]},{"id":"3d806225cd83","title":"里氏替换原则","parent":"7ea1ec4f2d4b","children":[{"id":"1f1b42f0a139","title":"所有引用其基类（父类）的地方都能透明的使用其子类对象","children":[],"parent":"3d806225cd83"}]},{"id":"f90359b8daf9","title":"接口隔离原则","parent":"7ea1ec4f2d4b","children":[{"id":"b043ccc01bf3","title":"使用多个单一的接口，而不是继承自一个总的接口<br>如Collection集合中的实现类，都分别单独继承Cloneable和Serializable接口，<br>而不是笼统的继承Collection接口","parent":"f90359b8daf9","children":[]}]},{"id":"e32a7625ef13","title":"合成复用原则","children":[{"id":"35ba3f29e842","title":"使用多各类的合成，而不是继承。我也没太懂","children":[],"parent":"e32a7625ef13"}],"parent":"7ea1ec4f2d4b"},{"id":"4a69e98ab89e","title":"迪米特原则","children":[{"id":"06869da22fde","title":"一个类尽量不要关联其他类，不要和陌生人说话","children":[],"parent":"4a69e98ab89e"}],"parent":"7ea1ec4f2d4b"}],"parent":"64d1bbbd3c0f"}],"note":"Object Oriented Programing\n\n如何理解面向对象？\nhttps://zhuanlan.zhihu.com/p/31251011"},{"id":"1e0583f9c070","title":"集合框架<br>java.util.*","link":{"title":"","value":"https://github.com/zhonghuasheng/JAVA/tree/master/basic/src/main/java/com/zhonghuasheng/basic/java/util","type":"url"},"parent":"300030983c2e","children":[{"id":"84cc8fc1e512","title":"Collection<br>","parent":"1e0583f9c070","children":[{"id":"9ca932772b7a","title":"List","children":[{"id":"c29bcb0a08d5","title":"ArrayList","children":[],"parent":"9ca932772b7a","note":"1. ArrayList是一个数据集合，相当于一个动态数组(Object[] elementData)。与Java中的数据相比，它的容量能动态增长，默认长度时10(DEFAULT_CAPACITY)，扩容时新的容量=原始容量 + 原始容量&gt;&gt;1\n2. ArrayList实现了RandomAccess接口（Marker Interface），又由于其数据以数据存储，因此支持快速随机查找，但是修改和删除效率不高\n```java\n// Collections中通过RandomAccess接口判断\n    public static &lt;T&gt;\n    int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) {\n        if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n            return Collections.indexedBinarySearch(list, key);\n        else\n            return Collections.iteratorBinarySearch(list, key);\n    }\n```\n3. ArrayList不是线程安全的，Vertor是线程安全的（其绝大部分方法都加了synchronized关键字），可在多线程下使用CopyOnWriteArryList。"},{"id":"58bf57ad85a6","title":"Vector","children":[],"parent":"9ca932772b7a","note":"1. Vector是一个矢量队列，支持基本的添加、修改、删除、遍历等功能\n2. Vector实现了RandomAccess接口，即支持随机访问功能（get(int index)）\n3. Vector中的public API都是加了synchronized关键字来保证线程安全"}],"parent":"84cc8fc1e512","note":"List是有序的，支持随机访问（通过索引下标访问）\nList允许重复的值（原因是它的数据存储方式）"},{"id":"2783aae0cdc6","title":"Set","children":[{"id":"f233b1767151","title":"TreeSet","children":[],"parent":"2783aae0cdc6","note":"1. TreeSet是一个有序并且没有重复的Set集合，它是通过TreeMap实现的\n2. TreeSet实现了NavigableSet接口，因此其支持集合的导航方法，如lower（返回小于）, floor（返回小于等于）, ceiling（返回大于等于）, higher（返回大于），如果不存在这样的元素，则返回null"},{"id":"64bd8783b435","title":"HashSet","children":[],"parent":"2783aae0cdc6","note":"1. HashSet是一个没有重复元素的集合，它是由HashMap实现的（HashMap中key不能重复），不保证元素的顺序，而且HashSet允许使用null元素。\n2. HashSet是非同步的，因此如果多线程同时访问一个HashSet，而其中至少有一个线程修改了该HashSet夺得话，那么需要保持外部同步，通常可以对该Set的对象封装来完成同步操作，也可以使用Collections.synchronizedSet方法来完成。\n3. HashSet是通过Iterator迭代遍历的"}],"parent":"84cc8fc1e512","note":"Set是继承自Collection的接口，是一个不允许有重复元素的结合。\nAbstractSet是一个抽象类，继承自AbstractCollection，AbstractCollection实现了Set中的绝大部分函数\nHashSet和TreeSet是Set的两个实现类\n    HashSet依赖HashMap，它实际上是通过HashMap实现的，HashSet中的元素是无序的\n    TreeSet依赖TreeMap，它实际上是通过TreeMap实现的，TreeSet中的元素是有序的"},{"id":"e1999405d9ad","title":"Queue","children":[{"id":"9aea61c068cc","title":"LinkedList","children":[],"parent":"e1999405d9ad","note":"LinkedList实现了Deque接口，能对它进行双向列表操作，也就是说顺序访问会非常高效，随机访问效率比较低\nLinkedList不是线程安全的，可以通过List list = Collections.synchronizedList(new LinkedList(...))来转换，不过LinkedList的数据类型会丢失\nLinkedList中使用Node对象来存储数据"}],"parent":"84cc8fc1e512","note":"```java\npublic interface Queue&lt;E&gt; extends Collection&lt;E&gt; {\n    boolean add(e)\n    boolean offer(e)\n    E remove() // 返回队列的第一个元素，并且删除，如果队列为空，报NoSuchElementException\n    E poll() // 返回队列的第一个元素，并且删除，如果队列为空，返回null\n    E element() // 返回队列的第一个元素，不删除，如果队列为空，报NoSuchElementException\n    E peek() // 返回队列的第一个元素，不删除，如果队列为空，返回null\n}\n```\n\n主要是  LinkedList  实现了两个不同的接口  (Deque 和 Collection )\n\noffer 实现 Deque 接口的方法\n\nadd  实现Collection 接口方法\n\n使用的时候看应用场景\n\n作为List使用时,一般采用add / get方法来 加入/获取对象\n\n作为Queue使用时,才会采用 offer/poll/take等方法"}],"note":"Collection接口中定义了集合的添加(add, addAll)、移除(remove, removeAll)、清空(clear)、是否包含(contains)、长度等方法，以及转换为数组的方法，和转换为Iterator对象的方法\n"},{"id":"5ea2c96e91c3","title":"Map","parent":"1e0583f9c070","children":[{"id":"a339a93606cb","title":"TreeMap","children":[],"parent":"5ea2c96e91c3"},{"id":"2e971fcde83a","title":"HashMap","children":[],"parent":"5ea2c96e91c3","note":"HashMap继承于AbstractMap类，实现了Map接口。Map是&quot;key-value键值对&quot;接口，AbstractMap实现了&quot;键值对&quot;的通用函数接口。\nHashMap是通过&quot;拉链法&quot;实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。\n    table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的&quot;key-value键值对&quot;都是存储在Entry数组中的。\n    size是HashMap的大小，它是HashMap保存的键值对的数量。\n    threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=&quot;容量*加载因子&quot;，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。\n　　loadFactor就是加载因子。\n　　modCount是用来实现fail-fast机制的。"},{"id":"69a6eb06c5fb","title":"WeakHashMap","children":[],"parent":"5ea2c96e91c3"},{"id":"7c8eb81bdc37","title":"HashTable","children":[],"parent":"5ea2c96e91c3"}],"note":"Map是一个键值对的接口，Map&lt;K, V&gt;\nAbstractMap实现了Map接口，但是几乎没有实现Map中的方法，但是却定义了一些常用的方法\nSortedMap继承自Map接口，SortedMap中的内容是排序了的键值对，排序的方法是通过比较器（Comparator）\nNavigableMap是继承自SortedMap的接口，相对于SortedMap，NavigableMap有一系列的导航方法，如获取&gt;, &lt;, &gt;=, &lt;=的值\nTreeMap继承自AbstractMap，实现了NavigableMap接口，因此，TreeMap是有序的键值对\nHashMap继承自AbstractMap，没有实现SortedMap，因此，HashMap不是有序的键值对。HashMap允许插入key或者value为null的元素\nHashtable没有继承自AbstractMap，继承的是Dictionary，实现了Map接口，因此，Hashtable是无序的键值对。Hashtable不允许插入key或者value为null的元素，Hashtable的方法加了synchronized关键字，保证了线程的安全。\nWeakhashMap继承自AbstractMap，大致来说它与HashMap的键类型不同，WeakHashMap使用的是“弱键”（内存不足时会被GC收掉）"},{"id":"9136ce62baa0","title":"Concurrent","parent":"1e0583f9c070","children":[]}]}]},{"id":"72cdaf6157d0","title":"JavaEE","parent":"faef5486de7416c841d8","children":[]},{"id":"b2ff53ef985b","title":"Spring<br>","parent":"faef5486de7416c841d8","children":[]},{"id":"cd11b81fc52a","title":"SpringBoot<br>","parent":"faef5486de7416c841d8","children":[]},{"id":"c96167b4409d","title":"SpringCloud","parent":"faef5486de7416c841d8","children":[]},{"id":"eb064b7769fde75f0c06","title":"性能优化","parent":"faef5486de7416c841d8","children":[{"id":"77fd3eafe026a0babeac","title":"Tools","parent":"eb064b7769fde75f0c06","children":[{"id":"1950782f8248736ce14b","title":"JDK自带","parent":"77fd3eafe026a0babeac","children":[{"id":"bb11bf351ce824cb5f57","title":"1. Create and Build Applications","parent":"1950782f8248736ce14b","children":[{"id":"a552b7312f12bb8dd93e","title":"appletviewer","parent":"bb11bf351ce824cb5f57","children":[],"note":"用于运行并浏览applet小程序"},{"id":"378f941332b9205d9904","title":"extcheck","parent":"bb11bf351ce824cb5f57","children":[],"note":"扩展检测工具，主要用于检测指定的jar文件与当前已安装的Java SDK扩展之间是否存在版本冲突"},{"id":"5db69b35418c3cc87769","title":"jar","parent":"bb11bf351ce824cb5f57","children":[],"note":"jar文件管理工具，主要用于打包压缩、解压jar文件"},{"id":"fb33b9e13236b095ddb7","title":"java","parent":"bb11bf351ce824cb5f57","children":[],"note":"Java运行工具，用于运行.class字节码文件或.jar文件"},{"id":"48ce8b49bfc07c22b2dd","title":"javac","parent":"bb11bf351ce824cb5f57","children":[],"note":"Java编译工具（Java Compiler），用于编译Java源代码文件"},{"id":"da22ee53008f9e0c965a","title":"javadoc","parent":"bb11bf351ce824cb5f57","children":[],"note":"Java文档工具，主要用于根据Java源代码中的注释信息生成HTML格式的API帮助文档"},{"id":"6c11959fcf2a1d7cfb3d","title":"javah","parent":"bb11bf351ce824cb5f57","children":[],"note":"Java头文件工具，用于根据Java类生成C/C++头文件或源文件（主要用于JNI开发领域）"},{"id":"0354ae01edebb8222b02","title":"javap","parent":"bb11bf351ce824cb5f57","children":[],"note":"Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件"},{"id":"a84f2c87c1166768ad52","title":"jdb","parent":"bb11bf351ce824cb5f57","children":[],"note":"Java调试工具（Java Debugger），主要用于对Java应用进行断点调试"},{"id":"662384af4343191f73c1","title":"jdeps","parent":"bb11bf351ce824cb5f57","children":[],"note":"Java Dependences，用于分析Java Class的依赖关系"}]},{"id":"0019765b743c94cce380","title":"2. Security","parent":"1950782f8248736ce14b","children":[{"id":"be811cdc66cb50adf9fe","title":"keytool","parent":"0019765b743c94cce380","children":[],"note":"密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等。主要用于获取或缓存Kerberos协议的票据授权票据。允许用户管理存储于本地密钥表中的主要名称和服务密钥"},{"id":"b323292a505a167b1994","title":"jarsigner","parent":"0019765b743c94cce380","children":[],"note":"jar密钥签名工具"},{"id":"f72c6ca24c747697ba01","title":"policytool","parent":"0019765b743c94cce380","children":[],"note":"策略工具，用于管理用户策略文件（.java.policy）"}]},{"id":"2d0307a2151f92c52f40","title":"3. Internationalization","parent":"1950782f8248736ce14b","children":[{"id":"43219789582409d00670","title":"native2ascii","parent":"2d0307a2151f92c52f40","children":[],"note":"本地编码到ASCII编码的转换器（Native-to-ASCII Converter），用于“任意受支持的字符编码”和与之对应的“ASCII编码和（或）Unicode转义”之间的相互转换"}]},{"id":"04f9635285a54afee471","title":"4. Remote Method Invocation(RMI)","parent":"1950782f8248736ce14b","children":[{"id":"3d055fdd2b4d480bf4bc","title":"rmic","parent":"04f9635285a54afee471","children":[],"note":"Java RMI编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMG IDL"},{"id":"11263d11c41c4bc97dcf","title":"rmiregistry","parent":"04f9635285a54afee471","children":[],"note":"Java远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表"},{"id":"27f40ec2811a547a68d1","title":"rmid","parent":"04f9635285a54afee471","children":[],"note":"Java RMI激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象"},{"id":"8df287fad84b14210ff1","title":"serialver","parent":"04f9635285a54afee471","children":[],"note":"序列版本命令，用于生成并返回serialVersionUID"}]},{"id":"c5f95cf2b931ab0e8de6","title":"5. Java IDL and RMI-IIOP","parent":"1950782f8248736ce14b","children":[{"id":"bfa5669c6d7115853ee3","title":"tnameserv","parent":"c5f95cf2b931ab0e8de6","children":[],"note":"Java IDL瞬时命名服务"},{"id":"947a602b8a0b31406ff4","title":"idlj","parent":"c5f95cf2b931ab0e8de6","children":[],"note":"IDL转Java编译器（IDL-to-Java Compiler），用于为指定的IDL文件生成Java绑定。IDL意即接口定义语言（Interface Defination Language）"},{"id":"ddbf4978d6f77fe73979","title":"orbd","parent":"c5f95cf2b931ab0e8de6","children":[],"note":"对象请求代理守护进程（Object Request Broker Daemon），它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象"},{"id":"3dd9186f15e6d2130966","title":"servertool","parent":"c5f95cf2b931ab0e8de6","children":[],"note":"Java DIL服务器工具，用于注册、取消注册、启动和终止持久化的服务器"}]},{"id":"0b90c8a7d3512e9dccd6","title":"6. Deploy Applications and Applets","parent":"1950782f8248736ce14b","children":[{"id":"abeb0d853b0e4ed05104","title":"pack200","parent":"0b90c8a7d3512e9dccd6","children":[],"note":"JAR文件打包压缩工具，它可以利用Java类特有的结构，对普通的JAR文件进行高效压缩，以便于能够更快进行网络传输。这是微软提供的对象包装程序，用于对象安装包"},{"id":"4606dfdaae099e64f110","title":"unpack200","parent":"0b90c8a7d3512e9dccd6","children":[],"note":"JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件"},{"id":"628dae2822f570379609","title":"javapackager","parent":"0b90c8a7d3512e9dccd6","children":[],"note":"执行针对Java应用程序和JavaFX应用程序的打包和签名的任务。包含了javafxpackager的功能"},{"id":"10e4f91194ef9d345a62","title":"javafxpackager","parent":"0b90c8a7d3512e9dccd6","children":[],"note":"JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务。JDK 8u20已经迁移此工具到javapackager"}]},{"id":"9ea3a98398952e4fe0a6","title":"7. Java Web Start","parent":"1950782f8248736ce14b","children":[{"id":"94210bd467cc7e6ce1c0","title":"javaws","parent":"9ea3a98398952e4fe0a6","children":[],"note":"用于JAVA Web程序"}]},{"id":"779f13dfa2bea420ea18","title":"8. Monitor Java Applications","parent":"1950782f8248736ce14b","children":[{"id":"c69fc528c682f7ebf1e9","title":"jconsole","parent":"779f13dfa2bea420ea18","children":[],"note":"图形化用户界面的检测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息"},{"id":"f0714fa8bef5335d2d58","title":"jvisualvm","parent":"779f13dfa2bea420ea18","children":[],"note":"JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息"}]},{"id":"28c9b5fb234e07fe77f1","title":"9. Monitor the JVM","parent":"1950782f8248736ce14b","children":[{"id":"b1721032bdbee5c8a4f4","title":"jps","parent":"28c9b5fb234e07fe77f1","children":[],"note":"JVM进程状态工具（JVM Process Status Tool），用于显示目标系统上的HotSpot JVM的Java进程信息"},{"id":"537805ad537e96631401","title":"jstat","parent":"28c9b5fb234e07fe77f1","children":[],"note":"JVM统计监测工具（JVM Statistics Monitoring Tool），主要用于检测并显示JVM的性能统计信息，包括gc统计信息"},{"id":"d8bdbbca9e3a9855190e","title":"jstatd","parent":"28c9b5fb234e07fe77f1","children":[],"note":"jstatd(VM jstatd Daemon)工具是一个RMI服务器应用，用于监测HotSpot JVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上"},{"id":"b0f7d537891b5280ee12","title":"jmc","parent":"28c9b5fb234e07fe77f1","children":[],"note":"Java任务控制工具(Java Mission Control)，主要用于HotSpot JVM的生产时间监测、分析、诊断。开发者可以使用jmc命令来创建JMC工具"}]},{"id":"9454494e7bb19a9556d3","title":"10. Web Services","parent":"1950782f8248736ce14b","children":[{"id":"e00256a8e4593406337a","title":"schemagen","parent":"9454494e7bb19a9556d3","children":[],"note":"XML schema生成器，用于生成XML schema文件"},{"id":"ba55d147901df9a8909b","title":"wsgen","parent":"9454494e7bb19a9556d3","children":[],"note":"XML Web Service 2.0的Java API，生成用于JAX-WS Web Service的JAX-WS便携式产物"},{"id":"9bbed81cb7c051592ce9","title":"wsimport","parent":"9454494e7bb19a9556d3","children":[],"note":"XML Web Service 2.0的Java API，主要用于根据服务端发布的wsdl文件生成客户端存根及框架"},{"id":"d9ad936039b5f1aa0477","title":"xjc","parent":"9454494e7bb19a9556d3","children":[],"note":"主要用于根据XML schema文件生成对应的Java类"}]},{"id":"17db5e5f25b73c18e891","title":"11. Troubleshooting","parent":"1950782f8248736ce14b","children":[{"id":"a36e1444a2b4e9bce428","title":"jcmd","parent":"17db5e5f25b73c18e891","children":[],"note":"Java命令行（Java Command），用于向正在运行的JVM发送诊断命令请求"},{"id":"c9f3a4fea5dd3d6a0799","title":"jinfo","parent":"17db5e5f25b73c18e891","children":[],"note":"Java配置信息工具（Java Configuration Information），用于打印指定Java进程、核心文件或远程调试服务器的配置信息"},{"id":"6f741b808c11ee015f72","title":"jhat","parent":"17db5e5f25b73c18e891","children":[],"note":"Java堆分析工具（Java Heap Analysis Tool），用于分析Java堆内存中的对象信息"},{"id":"170c1264881765c9c5cd","title":"jmap","parent":"17db5e5f25b73c18e891","children":[],"note":"Java内存映射工具（Java Memory Map），主要用于打印指定Java进程、核心文件或远程调用服务器的共享对象内存映射或堆内存细节"},{"id":"4925808537da5d22196c","title":"jsadebugd","parent":"17db5e5f25b73c18e891","children":[],"note":"Java可用性代理调试守护进程（Java Serviceability Agent Debug Daemon），主要用于附加到指定的Java进程、核心文件、或充当一个调试服务器"},{"id":"4cc25d3cf36261f5a7cb","title":"jstack","parent":"17db5e5f25b73c18e891","children":[],"note":"Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息"}]},{"id":"f9ede8967e8d74626ad8","title":"12. Scripting","parent":"1950782f8248736ce14b","children":[{"id":"f675b92782d505474270","title":"jrunscript","parent":"f9ede8967e8d74626ad8","children":[],"note":"Java命令行脚本外壳工具（command line script shell），主要用于解释执行javascript、groovy、ruby等脚本语言"},{"id":"3d47234d6b1387748107","title":"jjs","parent":"f9ede8967e8d74626ad8","children":[],"note":"对Nashorn引擎的调用。Nashorn是基于Java实现一个轻量级高性能的Javascript运行环境"}]}]},{"id":"6bdf80772795bb5adba7","title":"付费工具","parent":"77fd3eafe026a0babeac","children":[{"id":"ac45f2f9481ea59e87fb","title":"AppDynamic","parent":"6bdf80772795bb5adba7","children":[{"id":"4fbca90801ef","title":"* 在setenv.sh中配置agent<br>","parent":"ac45f2f9481ea59e87fb","children":[]}]},{"id":"671a5115b54a0f7ee9f4","title":"NewRelic","parent":"6bdf80772795bb5adba7","children":[{"id":"b51e7bd7a1f3","title":"* 在newrelic.yml中配置license key<br>* 在tomcat/bin/catalina.sh中配置agent<br>* 注意newrelic的日志会很大<br>","parent":"671a5115b54a0f7ee9f4","children":[]}]},{"id":"d2e16f8b512f1562aae2","title":"透视宝","parent":"6bdf80772795bb5adba7","children":[]}]},{"id":"7e9c836f18d6d1e8c1e4","title":"开源工具","parent":"77fd3eafe026a0babeac","children":[{"id":"c1a1302cf8d92c545ad6","title":"Pinpoint","parent":"7e9c836f18d6d1e8c1e4","children":[],"note":"基于JAVA的大型分布式性能监控工具\nhttps://github.com/naver/pinpoint"},{"id":"d92aceeec37fedd8c3a0","title":"MoSKito","parent":"7e9c836f18d6d1e8c1e4","children":[]}]},{"id":"21adb19be1a0","title":"BTrace<br>运行时动态输出信息","children":[],"parent":"77fd3eafe026a0babeac"}]}],"collapsed":false}],"collapsed":false}],"collapsed":false}],"title":"技术栈<br>详细文档请到Github获取<br>https://github.com/zhonghuasheng/Tutorial<br>不定时每天更新笔记，欢迎Star，免费fork","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","text-align":"center","font-size":23,"background-color":"rgb(80, 194, 139)","border-style":"","font-family":"Arial","border-width":"0"},"root":true,"link":{"title":"","value":"https://github.com/zhonghuasheng/Tutorial","type":"url"},"background":"#ffffcc","theme":"basic","children":[{"id":"017645788507d1516089","title":"日志","parent":"root","children":[{"id":"7cfe3c4fef10086b71cc","title":"ELK Stack（集中式日志解决方案）","parent":"017645788507d1516089","children":[{"id":"f6846b33ad68468446a5","title":"Elasticsearch","parent":"7cfe3c4fef10086b71cc","children":[]},{"id":"000ccdb173a589cd2f8b","title":"Kibana","parent":"7cfe3c4fef10086b71cc","children":[]},{"id":"6e228f61d3266fec7078","title":"Logstash","parent":"7cfe3c4fef10086b71cc","children":[]},{"id":"80951a63a76d469f2414","title":"Filebeat","parent":"7cfe3c4fef10086b71cc","children":[]}]},{"id":"ed8d7f0823e14a6d4b01","title":"日志系统","parent":"017645788507d1516089","children":[{"id":"18fc7ae01dd7b20531de","title":"1. 收集-能够采集多种来源的日志数据","parent":"ed8d7f0823e14a6d4b01","children":[]},{"id":"65601f9ad7cc87d93fc3","title":"2. 传输-能够稳定的把日志数据传输到中央系统","parent":"ed8d7f0823e14a6d4b01","children":[]},{"id":"a97a0fe1798af041d244","title":"3. 存储-如何存储日志数据","parent":"ed8d7f0823e14a6d4b01","children":[]},{"id":"7c7b399e08787d3c21a2","title":"4. 分析-可以支持UI分析","parent":"ed8d7f0823e14a6d4b01","children":[]},{"id":"27beeae15ecee61822ab","title":"5. 警告-能够提供错误报告，监控机制","parent":"ed8d7f0823e14a6d4b01","children":[]}]}],"collapsed":true},{"id":"75057d9d450321a37432","title":"数据库","parent":"root","children":[{"id":"db0e1d878151","title":"数据库原理","parent":"75057d9d450321a37432","children":[{"id":"a8e8e4c4728c96b5db47","title":"理论","parent":"db0e1d878151","children":[{"id":"3907e1c03e3bed8560e4","title":"CAP理论","parent":"a8e8e4c4728c96b5db47","children":[],"note":"CAP理论是数据系统设计的基本理论，目前几乎所有的数据系统的设计都遵循了这个理论。CAP理论指出，分布式系统只能满足以下三项中的两项而不可能满足全部三项\n一致性（Consistency）所有节点在同一时间具有相同的数据\n可用性（Availability）保证每个请求不管成功或者失败都有响应\n分区容忍性（Partition tolerance）系统中任意信息的丢失或者失败不会影响系统的继续运作"}]},{"id":"900f02c9fd8d05de6c39","title":"DBProxy","children":[],"parent":"db0e1d878151"}]},{"id":"2667f4f531a2","title":"分布式数据库","children":[{"id":"cecf98db8388","title":"Aurora AWS上的分布式关系型数据库","children":[],"parent":"2667f4f531a2"}],"parent":"75057d9d450321a37432"},{"id":"3e427184d9c9","title":"P6SpyDriver  P6Spy 是针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。P6Spy 分发包包括P6Log，它是一 个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。","children":[],"parent":"75057d9d450321a37432"}],"collapsed":true},{"id":"91ba7081bd0c","title":"架构","style":{"border-radius":"5px","color":"rgb(255, 255, 255)","background-color":"rgb(80, 194, 139)","border":"0px none rgb(255, 255, 255)"},"children":[{"id":"e187d649a4fb","title":"软件工程的四个要求","parent":"91ba7081bd0c","children":[{"id":"d6cfd7f924e1","title":"可维护性","parent":"e187d649a4fb","children":[]},{"id":"dd29e4e9353e","title":"可扩展性","parent":"e187d649a4fb","children":[]},{"id":"7906e43bd32a","title":"可复用性","parent":"e187d649a4fb","children":[]},{"id":"d9da4d076eed","title":"灵活性好","parent":"e187d649a4fb","children":[]}],"note":"曹操改诗 -&gt; 活字印刷"},{"id":"07d188dc027b","title":"软件设计的六大原则","parent":"91ba7081bd0c","children":[{"id":"5bcc42016cf9","title":"单一职责","children":[],"parent":"07d188dc027b"},{"id":"c2d749743f24","title":"依赖倒置原则","children":[],"parent":"07d188dc027b"},{"id":"f01af53eae13","title":"里氏替换原则","children":[],"parent":"07d188dc027b"},{"id":"23b0aea51996","title":"开闭原则","children":[],"parent":"07d188dc027b"},{"id":"f85c51eddb48","title":"接口隔离原则","children":[],"parent":"07d188dc027b"},{"id":"11c110b668ac","title":"迪米特原则","parent":"07d188dc027b","children":[]}]},{"id":"8ba69f7df331","title":"性能优化","parent":"91ba7081bd0c","children":[{"id":"aacb529c150b","title":"性能监控","parent":"8ba69f7df331","children":[{"id":"126895cedca0","title":"CPU/Memory/RDS使用率","children":[],"parent":"aacb529c150b","note":"* 成熟的产品有国外的AWS CloudWatch,国内的阿里云监控\n* 如果没有产品的话，Linux中使用一些命令来查看，比如top命令"},{"id":"7106094fa077","title":"服务器并发用户数","children":[],"parent":"aacb529c150b","note":"### linux查看httpd进程数\n\n```bash\nps -ef | grep httpd | wc -l\n```\n\n### 查看Apache的并发请求数及其TCP连接状态\n```bash\nnetstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;\n```\n（这条语句是从新浪互动社区事业部技术总监王老大那儿获得的，非常不错）\n\n返回结果示例：\n\nLAST_ACK 5\nSYN_RECV 30\nESTABLISHED 1597\nFIN_WAIT1 51\nFIN_WAIT2 504\nTIME_WAIT 1057\n\n其中的SYN_RECV表示正在等待处理的请求数；ESTABLISHED表示正常数据传输状态；TIME_WAIT表示处理完毕，等待超时结束的请求数。\n\n### linux并发连接数查看\n\n\n#### 1、查看Web服务器（Nginx Apache）的并发请求数及其TCP连接状态：\n\n```bash\nnetstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;\n```\n\n```bash\nnetstat -n|grep  ^tcp|awk &#39;{print $NF}&#39;|sort -nr|uniq -c\n```\n或者：\n\n```bash\nnetstat -n | awk &#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,&quot;t&quot;,state[key]}&#39;\n```\n\n返回结果一般如下：\n\n``` \nLAST_ACK 5 （正在等待处理的请求数）\nSYN_RECV 30\nESTABLISHED 1597 （正常数据传输状态）\nFIN_WAIT1 51\nFIN_WAIT2 504\nTIME_WAIT 1057 （处理完毕，等待超时结束的请求数）\n```\n\n其他参数说明：\n\n``` \nCLOSED：无连接是活动的或正在进行\nLISTEN：服务器在等待进入呼叫\nSYN_RECV：一个连接请求已经到达，等待确认\nSYN_SENT：应用已经开始，打开一个连接\nESTABLISHED：正常数据传输状态\nFIN_WAIT1：应用说它已经完成\nFIN_WAIT2：另一边已同意释放\nITMED_WAIT：等待所有分组死掉\nCLOSING：两边同时尝试关闭\nTIME_WAIT：另一边已初始化一个释放\nLAST_ACK：等待所有分组死掉\n``` \n#### 2、查看Nginx运行进程数\n\n```bash\nps -ef | grep nginx | wc -l\n```\n返回的数字就是nginx的运行进程数，如果是apache则执行\n\n```bash\nps -ef | grep httpd | wc -l\n``` \n#### 3、查看Web服务器进程连接数：\n\n```bash\nnetstat -antp | grep 80 | grep ESTABLISHED -c\n``` \n#### 4、查看MySQL进程连接数：\n```bash\nps -axef | grep mysqld -c\n```"},{"id":"12be91e23a1f","title":"系统响应时间Lantency","children":[],"parent":"aacb529c150b"},{"id":"39c8128eab02","title":"In-service服务器数量","children":[],"parent":"aacb529c150b"},{"id":"252c19b90324","title":"DB Connection","children":[],"parent":"aacb529c150b"},{"id":"eeabacea1a9e","title":"文件上传数量变化","parent":"aacb529c150b","children":[]}]},{"id":"10ea34b58fe0","title":"硬件优化","parent":"8ba69f7df331","children":[]},{"id":"2a44c09a8bbe","title":"数据库优化","parent":"8ba69f7df331","children":[{"id":"b7791eb50d74","title":"P6SpyDriver  P6Spy 是针对数据库访问操作的动态监测框架，它使得数据库数据可无缝截取和操纵，而不必对现有应用程序的代码作任何修改。P6Spy 分发包包括P6Log，它是一 个可记录任何 Java 应用程序的所有JDBC事务的应用程序。其配置完成使用时，可以进行数据访问性能的监测。","parent":"2a44c09a8bbe","children":[]}]},{"id":"34ae32d03916","title":"JVM参数调优","parent":"8ba69f7df331","children":[]},{"id":"3583bc904adb","title":"代码优化","parent":"8ba69f7df331","children":[]}]},{"id":"84d07efe29c7","title":"API设计","children":[],"parent":"91ba7081bd0c"},{"id":"64030f073d05","title":"大型网站架构核心思想","children":[{"id":"4c0447b57875","title":"要素","children":[{"id":"1eebe8dea919","title":"性能","children":[{"id":"10f58594d4c2","title":"性能测试","children":[{"id":"be8a85d5b6c1","title":"不同视角下的性能","children":[],"parent":"10f58594d4c2"},{"id":"44a320c45f70","title":"基准","children":[],"parent":"10f58594d4c2"},{"id":"bae40ec48389","title":"指标","children":[],"parent":"10f58594d4c2"},{"id":"5a0faac9c7a1","title":"方法","children":[],"parent":"10f58594d4c2"},{"id":"3beb3b4efcbc","title":"报告、分析","children":[],"parent":"10f58594d4c2"},{"id":"16d011b24a5b","title":"优化方案","children":[],"parent":"10f58594d4c2"}],"parent":"1eebe8dea919"},{"id":"563effac8cde","title":"前端优化","children":[{"id":"4d062e56852e","title":"浏览器优化","children":[],"parent":"563effac8cde"},{"id":"8c30b34df4cc","title":"CDN加速","children":[],"parent":"563effac8cde"},{"id":"f10ad5b3e27e","title":"反向代理","parent":"563effac8cde","children":[]}],"parent":"1eebe8dea919"},{"id":"c2af2e38dc61","title":"后端优化","children":[{"id":"ee1b06b7e4c0","title":"使用分布式缓存","parent":"c2af2e38dc61","children":[]},{"id":"4ceb47868537","title":"集群化","parent":"c2af2e38dc61","children":[]},{"id":"ffb5982fe555","title":"异步调用","parent":"c2af2e38dc61","children":[]},{"id":"1a57a3a4cb7c","title":"代码优化","parent":"c2af2e38dc61","children":[]}],"parent":"1eebe8dea919"},{"id":"95612995d610","title":"存储优化","children":[{"id":"3662f8a71ec0","title":"硬件优化","parent":"95612995d610","children":[]},{"id":"709e48e210ee","title":"RAID","parent":"95612995d610","children":[]},{"id":"8586e0d85cd7","title":"分布式存储","parent":"95612995d610","children":[]},{"id":"c7ae3c75027c","title":"合适的存储数据结构","parent":"95612995d610","children":[]}],"parent":"1eebe8dea919"}],"parent":"4c0447b57875","note":"### 主要的优化手段\n* 使用缓存加速数据的读取\n* 使用集群提高吞吐能力\n* 使用异步消息加快请求响应及实现削峰\n* 使用代码优化改善应用程序性能 ","collapsed":false},{"id":"442be2d9f291","title":"可用性","parent":"4c0447b57875","children":[{"id":"d2044d071ced","title":"应用高可用","parent":"442be2d9f291","children":[{"id":"e3e45269506b","title":"集群","parent":"d2044d071ced","children":[]}]},{"id":"9af6aa58f47c","title":"服务高可用","parent":"442be2d9f291","children":[{"id":"092bbc3bc253","title":"集群","parent":"9af6aa58f47c","children":[]},{"id":"9f45c03f73e6","title":"隔离","parent":"9af6aa58f47c","children":[]},{"id":"fddac71a2c88","title":"超时","parent":"9af6aa58f47c","children":[]},{"id":"c059b9ebd0b9","title":"降级","parent":"9af6aa58f47c","children":[]},{"id":"f3c1ca07281e","title":"异步","parent":"9af6aa58f47c","children":[]}]},{"id":"53504cda37d7","title":"数据高可用","parent":"442be2d9f291","children":[{"id":"38304f184aa7","title":"集群","children":[],"parent":"53504cda37d7"},{"id":"64097ae7bece","title":"备份","children":[],"parent":"53504cda37d7"},{"id":"36fe12b0c90e","title":"分布式数据库的CAP原则","children":[],"parent":"53504cda37d7"}]},{"id":"8d2cb027e06b","title":"发布","parent":"442be2d9f291","children":[{"id":"202db6d2ae08","title":"测试","children":[],"parent":"8d2cb027e06b"},{"id":"1183b66d38cc","title":"预发布","children":[],"parent":"8d2cb027e06b"},{"id":"d1a3ba044ffe","title":"代码控制","children":[],"parent":"8d2cb027e06b"},{"id":"4ff588eb8fa7","title":"灰度发布","children":[],"parent":"8d2cb027e06b"}]},{"id":"8986c0e5758e","title":"监控","parent":"442be2d9f291","children":[]}],"collapsed":false},{"id":"8946cc5ed3fc","title":"扩展性","children":[{"id":"9c8453c3b31a","title":"解耦","children":[{"id":"e509ec43d4f9","title":"传统设计模式解耦","children":[],"parent":"9c8453c3b31a"},{"id":"44ee98cf5958","title":"异步消息队列机制解耦","children":[],"parent":"9c8453c3b31a"}],"parent":"8946cc5ed3fc"},{"id":"cce930c38f2b","title":"重用","children":[{"id":"f4a5ae25120d","title":"服务化","children":[],"parent":"cce930c38f2b"}],"parent":"8946cc5ed3fc"}],"parent":"4c0447b57875","collapsed":false},{"id":"b41786980405","title":"伸缩性","children":[{"id":"1a1c044cf4e1","title":"通过增减资源达到增减吞吐量","children":[],"parent":"b41786980405"},{"id":"4650739da1b8","title":"应用服务集群伸缩","children":[{"id":"1a06bf4618e8","title":"负载均衡","children":[{"id":"f24634cd4f28","title":"HTTP Redirect负载","children":[],"parent":"1a06bf4618e8"},{"id":"126125a5d36e","title":"DNS负载","children":[],"parent":"1a06bf4618e8"},{"id":"4dc075d0090d","title":"反向代理","children":[],"parent":"1a06bf4618e8"},{"id":"4a7a51325768","title":"IP负载","children":[],"parent":"1a06bf4618e8"},{"id":"67f4d1e13862","title":"4层负载LVS","children":[],"parent":"1a06bf4618e8"}],"parent":"4650739da1b8"},{"id":"3b6f01c6b76f","title":"分布式缓存集群伸缩","children":[],"parent":"4650739da1b8"},{"id":"1930efa80a10","title":"数据库集群伸缩","children":[{"id":"c19174981d6d","title":"RDBMS伸缩","children":[],"parent":"1930efa80a10"}],"parent":"4650739da1b8"},{"id":"1a06bf4618e8","title":"负载均衡","children":[{"id":"f24634cd4f28","title":"HTTP Redirect负载","children":[],"parent":"1a06bf4618e8"},{"id":"126125a5d36e","title":"DNS负载","children":[],"parent":"1a06bf4618e8"},{"id":"4dc075d0090d","title":"反向代理","children":[],"parent":"1a06bf4618e8"},{"id":"4a7a51325768","title":"IP负载","children":[],"parent":"1a06bf4618e8"},{"id":"67f4d1e13862","title":"4层负载LVS","children":[],"parent":"1a06bf4618e8"},{"id":"f24634cd4f28","title":"HTTP Redirect负载","children":[],"parent":"1a06bf4618e8"},{"id":"126125a5d36e","title":"DNS负载","children":[],"parent":"1a06bf4618e8"},{"id":"4dc075d0090d","title":"反向代理","children":[],"parent":"1a06bf4618e8"},{"id":"4a7a51325768","title":"IP负载","children":[],"parent":"1a06bf4618e8"},{"id":"67f4d1e13862","title":"4层负载LVS","children":[],"parent":"1a06bf4618e8"}],"parent":"4650739da1b8"},{"id":"3b6f01c6b76f","title":"分布式缓存集群伸缩","children":[],"parent":"4650739da1b8"},{"id":"1930efa80a10","title":"数据库集群伸缩","children":[{"id":"c19174981d6d","title":"RDBMS伸缩","children":[],"parent":"1930efa80a10"},{"id":"44e60098dce8","title":"NoSQL伸缩","children":[],"parent":"1930efa80a10"},{"id":"c19174981d6d","title":"RDBMS伸缩","children":[],"parent":"1930efa80a10"}],"parent":"4650739da1b8"}],"parent":"b41786980405"}],"parent":"4c0447b57875","collapsed":false},{"id":"75a35fb5ca56","title":"安全性","children":[{"id":"a2e821c8ed66","title":"WAF","children":[],"parent":"75a35fb5ca56"},{"id":"c49ac5d71b2b","title":"加密","children":[{"id":"8cbfe96711a1","title":"MD5","parent":"c49ac5d71b2b","children":[]},{"id":"1acbcd944d46","title":"对称加密","parent":"c49ac5d71b2b","children":[]},{"id":"ac8edfa24685","title":"非对称加密","parent":"c49ac5d71b2b","children":[]}],"parent":"75a35fb5ca56"},{"id":"643909b47654","title":"内容安全","children":[{"id":"2734544fa8f6","title":"过滤","children":[],"parent":"643909b47654"},{"id":"801170d057b7","title":"反垃圾","children":[],"parent":"643909b47654"},{"id":"770342edd4ff","title":"发爬虫","children":[],"parent":"643909b47654"}],"parent":"75a35fb5ca56"},{"id":"2d486d9d8320","title":"常见攻击","children":[{"id":"1f977b587b59","title":"XSS","parent":"2d486d9d8320","children":[]},{"id":"c71cda1e45ab","title":"CRSF","parent":"2d486d9d8320","children":[]},{"id":"6cd427203e96","title":"SQL注入攻击","parent":"2d486d9d8320","children":[]},{"id":"164ca17d3653","title":"文件上传漏洞","parent":"2d486d9d8320","children":[]},{"id":"4dca1f4cd451","title":"DOS / DDOS攻击","parent":"2d486d9d8320","children":[]}],"parent":"75a35fb5ca56"}],"parent":"4c0447b57875","collapsed":false}],"parent":"64030f073d05"}],"parent":"91ba7081bd0c"},{"id":"405bd344edbe","title":"分布式","children":[{"id":"c4aa113bc447","title":"CAP理论","children":[{"id":"af31c549548e","title":"Consistency 强一致性，保证数据中的数据完全一致（可以理解为写操作之后的读操作，必须返回该值）","children":[],"parent":"c4aa113bc447"},{"id":"b175d7db5562","title":"Avaiable 在系统异常时，仍然可以提供服务。这里的可用性，一方面要求系统可以正常的运行返回结果，另一方面同样对响应速度有一定的保障","children":[],"parent":"c4aa113bc447"},{"id":"d5f8d118ce01","title":"Partition Tolerance 分区容错","children":[],"parent":"c4aa113bc447","note":"### 分布式系统环境特点如下：\n\n1. 从网络同步模型上分为同步网络，异步网络，半同步网络三种\n    * 同步网络是指网络带宽与延迟都是可以保证的。实际上现在IP网络都不属于这种，满足这种的网络是ATM网络（注意不是我们常见的提款机ATM）。\n    * 异步网络则是指网络带宽与延迟都不确定，在异步网络发送的报文会丢失。我们正在使用主的IP网络属于这种。\n    * 部分同步网络处于这两者中间\n\n2. 系统异常是常态\n    * 电源\n    * 机器元件故障，如内存、硬盘\n    * 操作系统故障\n    * 软件故障与程序bug\n    * 资源耗尽，如CPU，内存，磁盘空间，网络带宽等\n3. 网络传输是不可靠的\n    * 丢包\n    * 延时\n    * 乱序\n4. 并发\n5. 缺少全局时钟\n    * 分布式系统不同节点很难有相同的时钟"}],"parent":"405bd344edbe","note":"CAP理论，三者不能同时满足，所以出现容错。\n* CA 满足的情况下，P不能满足的原因：\t数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足\n* CP 满足的情况下，A不能满足的原因：\t数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足\n* AP 满足的情况下，C不能满足的原因：\t机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足\n\n使用场景 注册中心选择：\t* Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足\t* Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化\n\n* 结论：分布式系统中P,肯定要满足，所以只能在CA中二选一\t没有最好的选择，最好的选择是根据业务场景来进行架构设计\n\n* 如果要求一致性，则选择zookeeper，如金融行业\t\t\t        \n\n* 如果要去可用性，则Eureka，如电商系统"},{"id":"3131102b39d9","title":"分布式存储系统<br>如GFS","parent":"405bd344edbe","children":[{"id":"a7548be81e23","title":"结构化存储<br>structured storage system","parent":"3131102b39d9","children":[{"id":"ab2d7489a960","title":"MySQL / PostgreSQL","parent":"a7548be81e23","children":[]},{"id":"aa5cd5e360ee","title":"传统的结构化存储系统强调的是：<br>（1）结构化的数据（如关系表）<br>（2）强一致性<br>（3）随机访问（索引，CRUD，SQL语言）","parent":"a7548be81e23","children":[],"note":"Data Consistency\n强一致性可以理解为在任意时刻，所有节点中的数据是一样的。同一时间点，你在节点A中获取到key1的值与在节点B中获取到key1的值应该都是一样的\n弱一致性 （相当于异步）系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。\n一致性弱意味着对某个值修改后，可能后续还会读出来旧值。\n所谓最终一致性，就是不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。也可以简单的理解为在一段时间后，节点间的数据会最终达到一致状态。"}]},{"id":"81ea5c94ea05","title":"非结构化存储<br>no-structed storage system","parent":"3131102b39d9","children":[{"id":"4721c9c342a8","title":"非结构化存储强调的是高可扩展性，典型的系统就是分布式文件系统。<br>缺点就是无法支持随机访问random access操作","parent":"81ea5c94ea05","children":[]}]},{"id":"4b85d5b4b28b","title":"半结构化存储<br>semi-structure storage system","parent":"3131102b39d9","children":[{"id":"395fff510d11","title":"解决非结构化存储系统随机访问性能差的问题<br>NoSQL\\Key-Value Store等<br>NoSQL系统既有分布式文件系统所具有的可扩展性，<br>又有结构化存储系统的随机访问能力（如update/read） 如HBase, Google Bigtable","parent":"4b85d5b4b28b","children":[]}]},{"id":"2ad35815819c","title":"In-memory存储","parent":"3131102b39d9","children":[{"id":"3ac44107089d","title":"业务的高并发，存储系统对低延迟的要求越来越高，<br>内存价格的降低，基于内存的存储系统开始普及。<br>memcahed, redis-基于磁盘的存储系统做cache","parent":"2ad35815819c","children":[]}]},{"id":"3fdfd97c1b6d","title":"NewSQL","parent":"3131102b39d9","children":[{"id":"b53096c6e788","title":"兼备 RDBMS 的特性（例如：完整的 SQL 支持，ACID 事务支持），<br>又能像 NoSQL 系统那样具有强大的可扩展能力 - Google Spanner研发当中","parent":"3fdfd97c1b6d","children":[]}]}]},{"id":"53ad23e5bb73","title":"分布式计算系统<br>如MapReduce","children":[{"id":"2dc9894a3d2d","title":"传统基于msg的系统","children":[],"parent":"53ad23e5bb73"},{"id":"547acad5ad32","title":"MapReduce-like系统","children":[{"id":"b1fd001c8bd4","title":"MapReduce(Hadoop和Spark为代表) / Hive","children":[],"parent":"547acad5ad32"}],"parent":"53ad23e5bb73"},{"id":"47d97c2d764f","title":"图计算系统","children":[],"parent":"53ad23e5bb73"},{"id":"d88b2feefa91","title":"基于状态(state)的系统","children":[],"parent":"53ad23e5bb73"},{"id":"f960edd412ff","title":"Streaming系统","children":[{"id":"30231935dc66","title":"为流式数据提供服务，如storm.spark straming, flink","children":[],"parent":"f960edd412ff"}],"parent":"53ad23e5bb73"}],"parent":"405bd344edbe","note":"作者：马超\n链接：https://www.zhihu.com/question/23645117/answer/124708083\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n聊完了分布式存储系统，让我们来聊聊分布式计算系统 ：） 首先解决一个很多初学分布式计算的同学的疑惑：分布式计算和并行计算是一回事吗？最初我也有这样的疑惑，而现在我的理解是这样的：传统的并行计算要的是：投入更多机器，数据大小不变，计算速度更快。分布式计算要求：投入更多的机器，能处理更大的数据。换句话说二者的出发点从一开始就不同，一个强调 high performance, 一个强调 scalability. 举例来说，MapReduce 给业界带来的真正的思考是什么？其实是给我们普及了 google 这样级别的公司对真正意义上的「大数据」的理解。因为在 04 年论文出来之前，搞并行计算的人压根连 「容错」的概念都没有。换句话说，分布式计算最为核心的部分就是「容错」，没有容错，分布式计算根本无从谈起。MapReduce 统要做成这个样子（map ＋ reduce），其实就是为了容错。然而很多初学分布式计算的同学对容错的概念多多少少是有误解的。包括我在初学 mapreduce 的时候也会思考：好好的计算怎么就会出错了呢？一方面，由于硬件的老化，有可能会导致某台存储设备没有启动起来，某台机器的网卡坏了，甚至于计算运行过程中断电了，这些都是有可能的。然而最平凡发生的错误是计算进程被杀掉。因为 google 的运行环境是共有集群，任何一个权限更高的进程都可能 kill 掉你的计算进程。设想在一个拥有几千台机器的集群中运行，一个进程都不被 kill 掉的概率几乎为零。具体的容错机制我们会在后面介绍具体的系统时提到。"},{"id":"161bc22506a8","title":"分布式锁<br>如Chobby","parent":"405bd344edbe","children":[]},{"id":"303696760214","title":"分布式数据库<br>如BigTable, Spanner","parent":"405bd344edbe","children":[]},{"id":"6bcb27b09ecf","title":"分布式MQ<br>如Kafka","children":[],"parent":"405bd344edbe"},{"id":"b0d18fe275af","title":"分布式ML<br>如TensorFlow","children":[],"parent":"405bd344edbe"},{"id":"12088c510bef","title":"产品工具","parent":"405bd344edbe","children":[{"id":"91ac5f01d7f1","title":"分布式配置中心","parent":"12088c510bef","children":[{"id":"82e50d36f2b0","title":"Apollo 阿波罗 携程框架","parent":"91ac5f01d7f1","children":[],"note":"Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。"}]},{"id":"d374581af17b","title":"分布式日志手机系统ELK","parent":"12088c510bef","children":[{"id":"51e7e59e5b27","title":"Logstash","parent":"d374581af17b","children":[{"id":"451047838b53","title":"收集和分析","parent":"51e7e59e5b27","children":[]}]},{"id":"2fa199f0f0c5","title":"Elasticsearch","parent":"d374581af17b","children":[{"id":"195d99126cdf","title":"搜索与存储","parent":"2fa199f0f0c5","children":[]}]},{"id":"b624f5a327a6","title":"Kabana","parent":"d374581af17b","children":[{"id":"ca4495793952","title":"可视化展示","parent":"b624f5a327a6","children":[]}]},{"id":"02b0ab9f0853","title":"可配合Kafka使用","parent":"d374581af17b","children":[]}],"note":"ELK主要是为了在海量的日志系统里面实现分布式日志数据的集中式管理和查询，便于监控以及排查故障。"}]}],"parent":"91ba7081bd0c","note":"分布式系统要做的任务就是把多台机器（节点）有机的组合、连接起来，让其协同完成一件任务，可以是计算任务，也可以是存储任务。\n\n先想想为什么会有分布式，分布式怎么来的。传统的电信、银行业，当业务量大了之后，普通服务器CPU/IO/网络到了100%，请求太慢怎么办？最直接的做法，升级硬件，反正也不缺钱，IBM小型机，大型机，采购了堆硬件。但是互联网不能这么干，互联网没有那么财大气粗，还有很多初创，能不能赚钱还不知道。所以就有了软件方面的解决方案：分布式系统，简单说，就是一台服务器不行，我用两台、10台、100台...这就要软件系统需要支持。  那么软件设计者就需要考虑了，那么多台机器，我如何让他们协同工作，这就需要一个调度中心（或注册中心）；肯定涉及到机器间通信，那么需要一个高效的RPC框架；一个请求过来了，如何分发，需要一个请求分发系统（负载均衡）；然后还要考虑每个角色都不能成为性能瓶颈；还有要能方便的进行横向扩展，还有考虑单节点故障。\n\n作者：有雨\n链接：https://www.zhihu.com/question/23645117/answer/129505434\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","collapsed":false}],"parent":"root","collapsed":true},{"id":"6aa054853217","title":"其他","children":[{"id":"8f09448f03d2","title":"测试","parent":"6aa054853217","children":[{"id":"c0cac26d378f","title":"ApacheBench 基准性能测试，不太好用","parent":"8f09448f03d2","children":[]},{"id":"adcc78577e5e","title":"JMeter 可视化界面与命令行操作皆可，好用，功能完全","parent":"8f09448f03d2","children":[]}],"collapsed":true},{"id":"44829cef90ef","title":"APP<br>","children":[{"id":"b7b7d2a90ed7","title":"混合开发","parent":"44829cef90ef","children":[{"id":"84b643fc1b10","title":"Cordova + Vue","parent":"b7b7d2a90ed7","children":[]}]},{"id":"edd60e3fc364","title":"WebApp","parent":"44829cef90ef","children":[]},{"id":"eb0334433d08","title":"原生开发","parent":"44829cef90ef","children":[]}],"parent":"6aa054853217"},{"id":"a3cf49f3381c","title":"前端技术<br>","parent":"6aa054853217","children":[]},{"id":"826fd1d42fdd","title":"产品","children":[{"id":"7c6c4f638382","title":"新零售","children":[{"id":"a748c31a0ba7","title":"即时在库","children":[],"parent":"7c6c4f638382","note":"即时库存就是当库存发生异动，不管何时何地，皆应汇总计入库存。库存档内容包括店别、货号、进销类别、在途数量、实际数量。\n\n### 效益\n1、提供采购决策参考，建立以安全库存为基础的采购自动化机制。\n2、企业资源规划，提供各分店货品调拨据。\n3、避免畅销品缺货。\n4、确保客户交期。\n5、库存料帐是否相符的稽核标准。\n6、掌握即时进销存资讯，提供营业分析决策。\n7、精确计算变价盈亏，以利贩促企划。\n\n"},{"id":"e273e51e4db3","title":"精准化运营","children":[],"parent":"7c6c4f638382"}],"parent":"826fd1d42fdd"},{"id":"e63575216a685adf87b6","title":"数据中台","parent":"826fd1d42fdd","children":[{"id":"8c917af39b9fd233883e","title":"数据中台模式","parent":"e63575216a685adf87b6","children":[{"id":"22b6f1c56e1a42ccabfe","title":"全域数据采集","parent":"8c917af39b9fd233883e","children":[]},{"id":"f0c75710f1cf61a33bbe","title":"标准数据架构","parent":"8c917af39b9fd233883e","children":[]},{"id":"1fcbfcdd0623fa127be2","title":"连接数据价值","parent":"8c917af39b9fd233883e","children":[]},{"id":"4e8dbee5cca6c2c6a322","title":"数据资产管理","parent":"8c917af39b9fd233883e","children":[]},{"id":"cb7dd83729b61d7d1abb","title":"数据主题服务","parent":"8c917af39b9fd233883e","children":[]}]}],"collapsed":false}],"parent":"6aa054853217"}],"parent":"root","collapsed":false},{"id":"98cb8fe84a31","title":"微服务","parent":"root","children":[{"id":"d27f097fcb36","title":"微服务基础框架","parent":"98cb8fe84a31","children":[{"id":"73bb075f1912","title":"服务框架","parent":"d27f097fcb36","children":[]},{"id":"61946f8e9f3e","title":"运行时支撑服务","parent":"d27f097fcb36","children":[]},{"id":"b575f2b5c9e2","title":"后台服务","parent":"d27f097fcb36","children":[]},{"id":"ebab442ad88a","title":"服务容错","parent":"d27f097fcb36","children":[]},{"id":"1aa6153d10e3","title":"服务监控","parent":"d27f097fcb36","children":[]},{"id":"6fafb5f29415","title":"服务部署平台","parent":"d27f097fcb36","children":[]},{"id":"c7f6b8cefb33","title":"服务安全","parent":"d27f097fcb36","children":[]}],"note":"https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247489150&amp;idx=1&amp;sn=0e754da0ecaa16e16722df27dae26a26&source=41#wechat_redirect"}],"collapsed":false}],"lines":{"748c841a2084":{"id":"748c841a2084","to":"1e0583f9c070","realStart":{"y":9914.4,"x":9393.109375},"start":{"index":2,"y":"0.1","x":"1.0"},"styles":{"lineColor":"rgb(113, 203, 45)","color":"#ffffff","lineWidth":2},"realEnd":{"y":9954},"from":"1e0583f9c070","points":[{"y":9959.16940612793},{"y":9959.16940612793}],"end":{"index":3,"y":"1.0","x":"NaN"},"pts":[{"y":27.169406127930415},{"y":27.169406127930415}]}}}},"meta":{"id":"5c9867cce4b0afc7441ea761","member":"59521eb4e4b0ad619ac6279a","exportTime":"2019-05-21 16:07:07","diagramInfo":{"category":"mind_free","title":"JAVA开发大全","created":"2019-03-25 13:31:56","creator":"59521eb4e4b0ad619ac6279a","modified":"2019-05-21 16:06:41"},"type":"ProcessOn Schema File","version":"1.0"}}